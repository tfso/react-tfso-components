{"version":3,"sources":["../src/lib/InfiniteScroll.tsx"],"names":["React","throttle","fn","running","args","window","requestAnimationFrame","InfiniteScroll","_reachedTreshold","_lastScrollTop","_ref","createRef","onScroll","node","current","clientHeight","scrollTop","scrollHeight","props","threshold","onReachEnd","onReachTreshold","thresholdPoint","thresholdReachable","end","reachedTreshold","reachedEnd","console","log","height","width","overflowY","children","PureComponent","defaultProps","treshold"],"mappings":"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","sourcesContent":["import React from 'react'\nimport PropTypes from 'prop-types'\n\nconst throttle = (fn: (...args: any[]) => void) => {\n    let running = false\n    return (...args: any[]) => {\n        if(!running){\n            // TODO: Use timeout if RAF is unavailable\n            window.requestAnimationFrame(() => {\n                fn(args)\n                running = false\n            })\n            running = true\n        }\n    }\n}\n\nexport type InfiniteScrollProps = {\n    /**\n     * Invoked when the bottom of the scrollcontainer is reached\n     */\n    onReachEnd?: () => void\n\n    /**\n     * Invoked when the treshold distance to the bottom of the scrollcontainer is reached\n     */\n    onReachTreshold?: () => void\n\n    /**\n     * A number >= 0 and < 1\n     * Defines in percentage (factor) of the viewable containers height the distance from the bottom where the threshold is\n     * @default 0.1\n     */\n    threshold?: number\n\n    /**\n     * The height of the container\n     * @default 'calc(100%)'\n     */\n    height?: string | number\n\n    /**\n     * Children, whatever you want\n     */\n    children: React.ReactNode\n}\n\nexport default class InfiniteScroll extends React.PureComponent<InfiniteScrollProps>{\n    static defaultProps = {\n        treshold: 0.1,\n        height: 'calc(100%)'\n    }\n\n    static propTypes = {\n        onReachEnd: PropTypes.func,\n        onReachThreshold: PropTypes.func,\n        threshold: function(props: InfiniteScrollProps, propName: string, componentName: string){\n            const propValue = props[propName]\n            if(propValue === undefined){\n                return\n            }\n\n            const propType = typeof propValue\n            if(propType !== 'number'){\n                return new Error(`Invalid prop \\`${propName}\\` of value \\`${propValue}\\` supplied to \\`${componentName}\\`, expected a number.`)\n            }\n            if(propValue >= 1 || propValue < 0){\n                return new Error(`Invalied prop ${propValue} of value \\`${propName}\\` supplied to \\`${componentName}\\`, expected a number < 1 and >= 0.`)\n            }\n        },\n        height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n        children: PropTypes.node.isRequired,\n    }\n\n    // Initially we must assume that the end is nigh\n    // Lest we prematurely raise the event\n    // (Because the children may not be spawned, and the clientHeight may be less than the scrollHeight)\n    // Also, keeping this 'state' as regular ol class members, since we don't actually want a re-render after mutating these\n    _reachedTreshold = true\n    _lastScrollTop = 0\n\n    _ref: React.RefObject<HTMLDivElement> = React.createRef()\n\n    onScroll = throttle(() => {\n        const node = this._ref.current\n        if(!node){ return }\n\n        const {clientHeight, scrollTop, scrollHeight} = node\n        if(clientHeight >= scrollHeight){ return }\n\n        const {threshold = 0.1, onReachEnd, onReachTreshold} = this.props\n        const thresholdPoint = scrollHeight - clientHeight * threshold\n        const thresholdReachable = clientHeight < thresholdPoint\n        const end = clientHeight + scrollTop\n        const reachedTreshold = end >= thresholdPoint\n        const reachedEnd = end === scrollHeight\n\n        if(scrollTop <= this._lastScrollTop){\n            // Scrolling up\n            this._lastScrollTop = scrollTop\n            this._reachedTreshold = reachedTreshold\n            return\n        }\n        this._lastScrollTop = scrollTop\n\n        // Reaching the treshold can occur multiple times, handle differently\n        if(reachedTreshold){\n            if(!this._reachedTreshold || !thresholdReachable && reachedEnd){\n                onReachTreshold && onReachTreshold()\n                console.log('onReachThreshold')\n            }\n            this._reachedTreshold = true\n        }else if(this._reachedTreshold){\n            this._reachedTreshold = false\n        }\n\n        // Reaching the end can only occur once\n        if(reachedEnd){\n            onReachEnd && onReachEnd()\n            console.log('onReachEnd')\n        }\n    })\n\n    render(){\n        return (\n            <div style={{height: this.props.height || 'calc(100%)', width: '100%', overflowY: 'auto'}} ref={this._ref} onScroll={this.onScroll}>\n                {this.props.children}\n            </div>\n        )\n    }\n}"],"file":"InfiniteScroll.js"}