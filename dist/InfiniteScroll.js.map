{"version":3,"sources":["../src/lib/InfiniteScroll.tsx"],"names":["React","throttle","fn","running","args","window","requestAnimationFrame","InfiniteScroll","_reachedTreshold","_lastScrollTop","_mounted","_ref","createRef","onScroll","node","current","clientHeight","scrollTop","scrollHeight","props","threshold","onReachEnd","onReachThreshold","thresholdPoint","thresholdReachable","reachedTreshold","reachedEnd","scrollTo","top","height","overflowY","children","PureComponent","defaultProps","treshold"],"mappings":"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","sourcesContent":["import React from 'react'\nimport PropTypes from 'prop-types'\n\nconst throttle = (fn: (...args: any[]) => void) => {\n    let running = false\n    return (...args: any[]) => {\n        if(!running){\n            // TODO: Use timeout if RAF is unavailable\n            window.requestAnimationFrame(() => {\n                fn(args)\n                running = false\n            })\n            running = true\n        }\n    }\n}\n\nexport type InfiniteScrollProps = {\n    /**\n     * Invoked when the bottom of the scrollcontainer is reached\n     * Must be async, to prevent choppy scrolling\n     */\n    onReachEnd?: () => Promise<void>\n\n    /**\n     * Invoked when the treshold distance to the bottom of the scrollcontainer is reached\n     * Must be async, to prevent choppy scrolling\n     */\n    onReachThreshold?: () => Promise<void>\n\n    /**\n     * A number >= 0 and < 1\n     * Defines in percentage (factor) of the viewable containers height the distance from the bottom where the threshold is\n     * @default 0.1\n     */\n    threshold?: number\n\n    /**\n     * The height of the container\n     * @default 'calc(100%)'\n     */\n    height?: string | number\n\n    /**\n     * Children, whatever you want\n     */\n    children: React.ReactNode\n}\n\nexport default class InfiniteScroll extends React.PureComponent<InfiniteScrollProps>{\n    static defaultProps = {\n        treshold: 0.1,\n        height: 'calc(100%)'\n    }\n\n    static propTypes = {\n        onReachEnd: PropTypes.func,\n        onReachThreshold: PropTypes.func,\n        threshold: function(props: InfiniteScrollProps, propName: string, componentName: string){\n            const propValue = props[propName]\n            if(propValue === undefined){\n                return\n            }\n\n            const propType = typeof propValue\n            if(propType !== 'number'){\n                return new Error(`Invalid prop \\`${propName}\\` of value \\`${propValue}\\` supplied to \\`${componentName}\\`, expected a number.`)\n            }\n            if(propValue >= 1 || propValue < 0){\n                return new Error(`Invalied prop ${propValue} of value \\`${propName}\\` supplied to \\`${componentName}\\`, expected a number < 1 and >= 0.`)\n            }\n        },\n        height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n        children: PropTypes.node.isRequired,\n    }\n\n    // Initially we must assume that the end is nigh\n    // Lest we prematurely raise the event\n    // (Because the children may not be spawned, and the clientHeight may be less than the scrollHeight)\n    // Also, keeping this 'state' as regular ol class members, since we don't actually want a re-render after mutating these\n    _reachedTreshold = true\n    _lastScrollTop = 0\n    _mounted = false\n\n    _ref: React.RefObject<HTMLDivElement> = React.createRef()\n\n    componentDidMount(){\n        const node = this._ref.current\n        if(!node){ return }\n        node.scrollTo && node.scrollTo({top: 0}) // Dunno why, but for some reason the node is scrolled to bottom when mounting\n\n        this._mounted = true\n    }\n\n    onScroll = throttle(() => {\n        if(!this._mounted){ return }\n\n        const node = this._ref.current\n        if(!node){ return }\n\n        const {clientHeight, scrollTop, scrollHeight} = node\n        if(clientHeight >= scrollHeight){ return }\n\n        const {threshold = 0.1, onReachEnd, onReachThreshold} = this.props\n        const thresholdPoint = scrollHeight - clientHeight - clientHeight * threshold\n        const thresholdReachable = clientHeight < thresholdPoint\n        const reachedTreshold = scrollTop >= thresholdPoint\n        const reachedEnd = scrollTop + clientHeight === scrollHeight\n\n        if(scrollTop <= this._lastScrollTop){\n            // Scrolling up\n            this._lastScrollTop = scrollTop\n            this._reachedTreshold = reachedTreshold\n            return\n        }\n        this._lastScrollTop = scrollTop\n\n        // Reaching the treshold can occur multiple times, handle differently\n        if(reachedTreshold){\n            if(!this._reachedTreshold || (!thresholdReachable && reachedEnd)){\n                onReachThreshold && onReachThreshold()\n            }\n            this._reachedTreshold = true\n        }else if(this._reachedTreshold){\n            this._reachedTreshold = false\n        }\n\n        // Reaching the end can only occur once\n        if(reachedEnd){\n            onReachEnd && onReachEnd()\n        }\n    })\n\n    render(){\n        return (\n            <div style={{height: this.props.height || 'calc(100%)', overflowY: 'auto'}} ref={this._ref} onScroll={this.onScroll}>\n                {this.props.children}\n            </div>\n        )\n    }\n}"],"file":"InfiniteScroll.js"}