{"version":3,"sources":["../src/lib/TextFieldEditor.tsx"],"names":["React","TextField","handleEvent","event","preventDefault","stopPropagation","nativeEvent","stopImmediatePropagation","TextFieldEditor","_inputRef","createRef","state","editing","value","props","prevProps","blur","current","onKeyDown","defaultPrevented","ctrlKey","key","setState","multiline","onFocus","e","onBlur","onChange","target","dirtyProp","dirty","onChangeProp","valueProp","enableDirtyCheck","otherProps","isDirty","style","fontStyle","PureComponent"],"mappings":"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","sourcesContent":["import React from 'react'\nimport PropTypes from 'prop-types'\nimport TextField, {TextFieldProps} from '@material-ui/core/TextField'\n\ntype Props = {\n    value: string\n    onChange: (value: string) => void\n    dirty?: boolean\n    enableDirtyCheck?: boolean\n}\n\ntype State = {\n    editing: boolean\n    value: string\n    prevProps: Props\n}\n\ntype Omit<T, K> = Pick<T, Exclude<keyof T, K>>\n\nfunction handleEvent(event: React.KeyboardEvent<HTMLDivElement>){\n    event.preventDefault()\n    event.stopPropagation()\n    // the above only prevents other synthetic events, if we want to prevent global listeners too, we need to stop the propagation on the native event as well\n    event.nativeEvent.stopImmediatePropagation()\n}\n\nexport type TextFieldEditorProps = Props & Partial<Omit<TextFieldProps, 'value' | 'onChange'>>\n\nexport default class TextFieldEditor extends React.PureComponent<TextFieldEditorProps, State>{\n    static propTypes = {\n        value: PropTypes.string.isRequired,\n        onChange: PropTypes.func.isRequired,\n        dirty: PropTypes.bool\n    }\n\n    _inputRef: React.RefObject<HTMLInputElement> = React.createRef()\n\n    state: State = {\n        editing: false,\n        value: this.props.value,\n        prevProps: this.props\n    }\n\n    static getDerivedStateFromProps(props: Readonly<TextFieldEditorProps>, state: Readonly<State>){\n        const prevProps = state.prevProps\n\n        if(prevProps.value !== props.value){ return {value: props.value, prevProps: props} }\n\n        return {prevProps: props}\n    }\n\n    blur = () => { this._inputRef.current && this._inputRef.current.blur() }\n\n    onKeyDown = (event: React.KeyboardEvent<HTMLDivElement>) => {\n        this.props.onKeyDown && this.props.onKeyDown(event)\n        if(event.defaultPrevented){ return }\n\n        if(event.ctrlKey){\n            switch(event.key){\n            case 's':\n            // this event should not be 'handled' here (eg. invoke handleEvent(event)), control may want to perform other actions on ctrl+s\n            // It should behave as a save changes in the control as well however\n                this.blur()\n                break\n            case 'z':\n                handleEvent(event)\n                this.setState({editing: false, value: this.props.value}, this.blur)\n                break\n            default: break\n            }\n        }else{\n            switch(event.key){\n            case 'Enter':\n                if(this.props.multiline){ break }\n                handleEvent(event)\n                this.blur()\n                break\n            case 'Escape':\n                handleEvent(event)\n                this.setState({editing: false, value: this.props.value}, this.blur)\n                break\n            default: break\n            }\n        }\n    }\n\n    onFocus = (e: React.EventHandler<any>) => {\n        this.setState({editing: true})\n        this.props.onFocus && this.props.onFocus(e)\n    }\n\n    onBlur = (e: React.EventHandler<any>) => {\n        if(!this.state.editing){ return } // The method should be safe to call multiple times, but we don't want to raise the event multiple times if we dont need to\n\n        this.props.onChange(this.state.value)\n        this.setState({editing: false})\n        this.props.onBlur && this.props.onBlur(e)\n    }\n\n    onChange = (event: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement | HTMLSelectElement>) => {\n        const value = event.target.value\n        this.setState({value, editing: true})\n    }\n\n    render(){\n        const {dirty: dirtyProp, onChange: onChangeProp, value: valueProp, enableDirtyCheck, ...otherProps} = this.props\n        const {value} = this.state\n\n        const isDirty = enableDirtyCheck ? this.props.value !== value || !!dirtyProp : !!dirtyProp\n\n        return (\n            <TextField\n                {...otherProps as any}\n                inputRef={this._inputRef}\n                value={value}\n                onFocus={this.onFocus}\n                onChange={this.onChange}\n                onBlur={this.onBlur}\n                onKeyDown={this.onKeyDown}\n                InputProps={{style: {fontStyle: isDirty ? 'italic' : 'normal'}}}\n            />\n        )\n    }\n}"],"file":"TextFieldEditor.js"}