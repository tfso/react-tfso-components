{"version":3,"sources":["../../src/lib/GridLayout/utils.ts"],"names":["isEqual","React","bottom","layout","Object","values","map","item","row","height","reduce","max","bottomY","childrenEqual","a","b","Children","c","key","collides","l1","l2","id","col","width","compact","newLayout","sortedItems","sortLayoutItems","test","getFirstCollision","constrainCol","targetCol","columns","correctBounds","cols","l","layoutItems","target","find","getAllCollisions","filter","moveItem","itemId","hasOwnProperty","Error","source","correctedCol","collisions","movedItems","Set","collision","collissionMovedUp","Math","add","moveCollidingItem","collidesWith","collissionMovedDown","has","length","setTransform","top","left","translate","transform","position","uncollide","sortedItemIds","pickFromLayout","i","rest","slice","ascending","sort","synchronizeLayoutWithChildren","initialLayout","children","forEach","child","String","exists","validateLayout","contextName","subProps","j","autoBindHandlers","el","fns","bind"],"mappings":"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","sourcesContent":["import isEqual from 'lodash/isEqual'\nimport React from 'react'\n\nexport type LayoutItem = Readonly<{\n    width: number\n    height: number\n    col: number\n    row: number\n    id: string\n    // draggable?: boolean\n}>\nexport type Layout = Readonly<{[key: string]: LayoutItem}>\nexport type Position = Readonly<{\n    left: number\n    top: number\n    width: number\n    height: number\n}>\nexport type ReactDraggableCallbackData = {\n    node: HTMLElement\n    x: number\n    y: number\n    deltaX: number\n    deltaY: number\n    lastX: number\n    lastY: number\n}\n\nexport type PartialPosition = { left: number, top: number }\nexport type Size = { width: number, height: number }\nexport type GridDragEvent = {\n    e: Event\n    node: HTMLElement\n    newPosition: PartialPosition\n}\n\nexport type GridResizeEvent = { e: Event, node: HTMLElement, size: Size }\n\n// All callbacks are of the signature (layout, oldItem, newItem, placeholder, e).\nexport type EventCallback = (\n    layout: Layout,\n    oldItem: LayoutItem | null,\n    newItem: LayoutItem | null,\n    placeholder: LayoutItem | null,\n    event: Event,\n    node: HTMLElement\n) => void\n\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nexport function bottom(layout: Layout): number{\n    return Object.values(layout)\n        .map(item => item.row + item.height)\n        .reduce((max, bottomY) => bottomY > max ? bottomY : max, 0)\n}\n\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\nexport function childrenEqual(a: Array<React.ReactElement>, b: Array<React.ReactElement>): boolean{\n    return isEqual(\n        React.Children.map(a, c => c.key),\n        React.Children.map(b, c => c.key)\n    )\n}\n\n/**\n * Given two layoutitems, check if they collide.\n */\nexport function collides(l1: LayoutItem, l2: LayoutItem): boolean{\n    if(l1.id === l2.id) return false // same element\n\n    if(l1.col + l1.width <= l2.col) return false // l1 is left of l2\n    if(l1.col >= l2.col + l2.width) return false // l1 is right of l2\n\n    if(l1.row + l1.height <= l2.row) return false // l1 is above l2\n    if(l1.row >= l2.row + l2.height) return false // l1 is below l2\n\n    return true // boxes overlap\n}\n\nexport function compact(layout: Layout): Layout{\n    let newLayout = {}\n    const sortedItems = sortLayoutItems(layout)\n\n    for(let item of sortedItems){\n        while(true){\n            const test = {...item, row: item.row - 1}\n            if(test.row < 0 || !!getFirstCollision(Object.values(newLayout), test)){\n                break\n            }\n            item = test\n        }\n        newLayout[item.id] = item\n    }\n\n    return newLayout\n}\n\nexport function constrainCol(targetCol: number, width: number, columns: number){\n    if(width > columns || targetCol < 0){\n        return 0\n    }\n    if(targetCol + width > columns){\n        return columns - width\n    }\n    return targetCol\n}\n\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} cols Number of columns.\n */\nexport function correctBounds(layout: Layout, cols: number): Layout{\n    return Object.values(layout)\n        .map(item => {\n            let width = item.width > cols ? cols : item.width\n            let col = constrainCol(item.col, width, cols) // item.col + width > cols ? Math.max(cols - width, 0) : item.col\n            return item.col !== col || item.width !== width\n                ? {...item, width, col}\n                : item\n        })\n        .reduce((l, item) => {\n            l[item.id] = item\n            return l\n        }, {})\n}\n\nexport function getFirstCollision(layoutItems: ReadonlyArray<LayoutItem>, target: LayoutItem){\n    return layoutItems.find(item => collides(item, target))\n}\n\nexport function getAllCollisions(layoutItems: ReadonlyArray<LayoutItem>, target: LayoutItem){\n    return layoutItems.filter(item => collides(item, target)) as ReadonlyArray<LayoutItem>\n}\n\nexport function moveItem(\n    itemId: string,\n    layout: Layout,\n    col: number,\n    row: number,\n    cols: number\n){\n    if(!layout.hasOwnProperty(itemId)){\n        throw new Error('slutt')\n    }\n\n    const source = layout[itemId]\n    const correctedCol = constrainCol(col, source.width, cols)\n    const target = {...source, col: correctedCol, row}\n\n    let newLayout = {...layout, [source.id]: target}\n    const collisions = getAllCollisions(Object.values(newLayout), target)\n\n    if(!collisions){\n        return newLayout\n    }\n\n    const movedItems = new Set<string>([target.id])\n    for(const collision of collisions){\n        const collissionMovedUp = {\n            ...collision,\n            row: Math.max(target.row - collision.height, 0)\n        }\n\n        // Can switch places (move collision above target)\n        if(!getFirstCollision(Object.values(newLayout), collissionMovedUp)){\n            movedItems.add(collision.id)\n            newLayout = {...newLayout, [collision.id]: collissionMovedUp}\n        }else{\n            newLayout = moveCollidingItem(target, collision, newLayout, movedItems)\n        }\n    }\n    return newLayout\n}\n\nfunction moveCollidingItem(\n    source: LayoutItem,\n    collidesWith: LayoutItem,\n    layout: Layout,\n    movedItems: Set<string>\n){\n    movedItems.add(collidesWith.id)\n\n    const collissionMovedDown = {\n        ...collidesWith,\n        row: source.row + source.height\n    }\n\n    let newLayout = {...layout, [collissionMovedDown.id]: collissionMovedDown}\n    const collisions = Object.values(newLayout)\n        .filter(item => !movedItems.has(item.id) && collides(item, collissionMovedDown))\n\n    if(!collisions.length){\n        return newLayout\n    }\n\n    for(const collision of collisions){\n        newLayout = moveCollidingItem(collissionMovedDown, collision, newLayout, movedItems)\n    }\n\n    return newLayout\n}\n\nexport function setTransform({top, left, width, height}: Position): React.CSSProperties{\n    // Replace unitless items with px\n    const translate = `translate(${left}px,${top}px)`\n    return {\n        transform: translate,\n        // WebkitTransform: translate,\n        // MozTransform: translate,\n        // msTransform: translate,\n        // OTransform: translate,\n        width: `${width}px`,\n        height: `${height}px`,\n        position: 'absolute'\n    }\n}\n\nfunction uncollide(layout: Layout): Layout{\n    let newLayout = layout\n    const sortedItemIds = sortLayoutItems(layout)\n        .map(item => item.id)\n    const pickFromLayout = (id: string) => newLayout[id]\n    for(let i = 0; i < sortedItemIds.length - 1; i++){ // length - 1 because the last item won't collide with jack shit\n        while(true){\n            const item = newLayout[sortedItemIds[i]]\n            const rest = sortedItemIds.slice(i + 1).map(pickFromLayout)\n            const collision = getFirstCollision(rest, item)\n            if(!collision){\n                break\n            }\n            newLayout = moveCollidingItem(item, collision, newLayout, new Set([item.id]))\n        }\n    }\n    return newLayout\n}\n\nexport function sortLayoutItems(layout: Layout, ascending: boolean = true): ReadonlyArray<LayoutItem>{\n    return Object.values(layout).sort((a, b) => {\n        if(a.row > b.row || (a.row === b.row && a.col > b.col)){\n            return ascending ? 1 : -1\n        }else if(a.row === b.row && a.col === b.col){\n            // Without this, we can get different sort results in IE vs. Chrome/FF\n            return 0\n        }\n        return ascending ? -1 : 1\n    })\n}\n\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\nexport function synchronizeLayoutWithChildren(\n    initialLayout: Layout,\n    children: Array<React.ReactElement>,\n    cols: number\n): Layout{\n    // Generate one layout item per child.\n    let layout = {}\n    React.Children.forEach(children, (child: React.ReactElement<any>) => {\n        const id = String(child.key)\n        // Don't overwrite if it already exists.\n        const exists = initialLayout[id]\n        if(exists){\n            layout[id] = {...exists}\n        }else{\n            // Nothing provided: ensure this is added to the bottom\n            layout[id] = {\n                width: 1,\n                height: 1,\n                col: 0,\n                row: bottom(layout),\n                id\n            }\n        }\n    })\n\n    // Correct the layout.\n    layout = correctBounds(layout, cols)\n    layout = uncollide(layout)\n    layout = compact(layout)\n\n    return layout\n}\n\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\nexport function validateLayout(\n    layout: Layout,\n    contextName: string = 'Layout'\n): void {\n    const subProps: Array<keyof LayoutItem> = ['col', 'row', 'width', 'height']\n    for(const item of Object.values(layout)){\n        for(let j = 0; j < subProps.length; j++){\n            if(typeof item[subProps[j]] !== 'number'){\n                throw new Error(\n                    'GridLayout: ' +\n                    contextName +\n                    '[' +\n                    item.id +\n                    '].' +\n                    subProps[j] +\n                    ' must be a number!'\n                )\n            }\n        }\n        if(item.id && typeof item.id !== 'string'){\n            throw new Error(\n                'GridLayout: ' + contextName + ' item.id must be a string!'\n            )\n        }\n    }\n}\n\nexport function autoBindHandlers(el: Object, fns: Array<string>): void {\n    fns.forEach(key => (el[key] = el[key].bind(el)))\n}"],"file":"utils.js"}