{"version":3,"sources":["../../src/lib/GridLayout/responsiveUtils.ts"],"names":["compact","correctBounds","getBreakpointFromWidth","breakpoints","width","sorted","sortBreakpoints","matching","i","length","breakpointName","breakpoint","getColsFromBreakpoint","cols","numCols","Error","findOrGenerateResponsiveLayout","layouts","lastBreakpoint","layout","breakpointsSorted","breakpointsAbove","slice","indexOf","b","keys","Object","sort","a"],"mappings":";;;;AAAA,SAAQA,OAAR,EAAiBC,aAAjB,QAA6C,SAA7C;;AAMA;;;;;;;AAOA,OAAO,SAASC,sBAAT,CACHC,WADG,EAEHC,KAFG,EAGM;AACT,MAAMC,MAAM,GAAGC,eAAe,CAACH,WAAD,CAA9B;AACA,MAAII,QAAQ,GAAGF,MAAM,CAAC,CAAD,CAArB;;AACA,OAAI,IAAIG,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGH,MAAM,CAACI,MAA1B,EAAkCD,CAAC,EAAnC,EAAsC;AAClC,QAAME,cAAc,GAAGL,MAAM,CAACG,CAAD,CAA7B;AACA,QAAMG,UAAU,GAAGR,WAAW,CAACO,cAAD,CAA9B;AACA,QAAGC,UAAU,IAAIP,KAAK,GAAGO,UAAzB,EAAqCJ,QAAQ,GAAGG,cAAX;AACxC;;AACD,SAAOH,QAAP;AACH;AAED;;;;;;;AAMA,OAAO,SAASK,qBAAT,CACHD,UADG,EAEHE,IAFG,EAGE;AACL,MAAMC,OAAO,GAAGD,IAAI,CAACF,UAAD,CAApB;;AACA,MAAG,CAACG,OAAJ,EAAY;AACR,UAAM,IAAIC,KAAJ,CACF,4DACAJ,UADA,GAEA,cAHE,CAAN;AAKH;;AACD,SAAOG,OAAP;AACH;AAED;;;;;;;;;;;;;;;AAcA,OAAO,SAASE,8BAAT,CACHC,OADG,EAEHd,WAFG,EAGHQ,UAHG,EAIHO,cAJG,EAKHL,IALG,EAME;AACL;AACA,MAAGI,OAAO,CAACN,UAAD,CAAV,EAAwB,yBAAWM,OAAO,CAACN,UAAD,CAAlB,EAFnB,CAGL;;AACA,MAAIQ,MAAM,GAAGF,OAAO,CAACC,cAAD,CAApB;AACA,MAAME,iBAAiB,GAAGd,eAAe,CAACH,WAAD,CAAzC;AACA,MAAMkB,gBAAgB,GAAGD,iBAAiB,CAACE,KAAlB,CACrBF,iBAAiB,CAACG,OAAlB,CAA0BZ,UAA1B,CADqB,CAAzB;AANK;AAAA;AAAA;;AAAA;AASL,yBAAeU,gBAAf,8HAAgC;AAAA,UAAtBG,CAAsB;;AAC5B,UAAGP,OAAO,CAACO,CAAD,CAAV,EAAc;AACVL,QAAAA,MAAM,GAAGF,OAAO,CAACO,CAAD,CAAhB;AACA;AACH;AACJ;AAdI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAeLL,EAAAA,MAAM,GAAGA,MAAM,qBAAOA,MAAP,IAAiB,EAAhC;AACA,SAAOnB,OAAO,CAACC,aAAa,CAACkB,MAAD,EAASN,IAAT,CAAd,CAAd;AACH;AAED;;;;;;;;AAOA,OAAO,SAASP,eAAT,CAAyBH,WAAzB,EAAqE;AACxE,MAAMsB,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYtB,WAAZ,CAAb;AACA,SAAOsB,IAAI,CAACE,IAAL,CAAU,UAACC,CAAD,EAAIJ,CAAJ;AAAA,WAAU,CAACrB,WAAW,CAACyB,CAAD,CAAX,IAAkB,CAAnB,KAAyBzB,WAAW,CAACqB,CAAD,CAAX,IAAkB,CAA3C,CAAV;AAAA,GAAV,CAAP;AACH","sourcesContent":["import {compact, correctBounds, Layout} from './utils'\nimport {Breakpoint} from '@material-ui/core/styles/createBreakpoints'\n\nexport type ResponsiveLayout = {[BP in Breakpoint]?: Layout}\ntype Breakpoints = {[BP in Breakpoint]?: number}\n\n/**\n * Given a width, find the highest breakpoint that matches is valid for it (width > breakpoint).\n *\n * @param  {Breakpoints} breakpoints Breakpoints object (e.g. {lg: 1200, md: 960, ...})\n * @param  {Number} width Screen width.\n * @return {Breakpoint}       Highest breakpoint that is less than width.\n */\nexport function getBreakpointFromWidth(\n    breakpoints: Breakpoints,\n    width: number\n): Breakpoint{\n    const sorted = sortBreakpoints(breakpoints)\n    let matching = sorted[0]\n    for(let i = 1; i < sorted.length; i++){\n        const breakpointName = sorted[i]\n        const breakpoint = breakpoints[breakpointName]\n        if(breakpoint && width > breakpoint) matching = breakpointName\n    }\n    return matching\n}\n\n/**\n * Given a breakpoint, get the # of cols set for it.\n * @param  {String} breakpoint Breakpoint name.\n * @param  {Object} cols       Map of breakpoints to cols.\n * @return {Number}            Number of cols.\n */\nexport function getColsFromBreakpoint(\n    breakpoint: Breakpoint,\n    cols: Breakpoints\n): number{\n    const numCols = cols[breakpoint]\n    if(!numCols){\n        throw new Error(\n            'ResponsiveReactGridLayout: `cols` entry for breakpoint ' +\n            breakpoint +\n            ' is missing!'\n        )\n    }\n    return numCols\n}\n\n/**\n * Given existing layouts and a new breakpoint, find or generate a new layout.\n *\n * This finds the layout above the new one and generates from it, if it exists.\n *\n * @param  {Object} layouts     Existing layouts.\n * @param  {Array} breakpoints All breakpoints.\n * @param  {String} breakpoint New breakpoint.\n * @param  {String} breakpoint Last breakpoint (for fallback).\n * @param  {Number} cols       Column count at new breakpoint.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}             New layout.\n */\nexport function findOrGenerateResponsiveLayout(\n    layouts: ResponsiveLayout,\n    breakpoints: Breakpoints,\n    breakpoint: Breakpoint,\n    lastBreakpoint: Breakpoint,\n    cols: number\n): Layout{\n    // If it already exists, just return it.\n    if(layouts[breakpoint]) return {...layouts[breakpoint]!}\n    // Find or generate the next layout\n    let layout = layouts[lastBreakpoint]\n    const breakpointsSorted = sortBreakpoints(breakpoints)\n    const breakpointsAbove = breakpointsSorted.slice(\n        breakpointsSorted.indexOf(breakpoint)\n    )\n    for(const b of breakpointsAbove){\n        if(layouts[b]){\n            layout = layouts[b]\n            break\n        }\n    }\n    layout = layout ? {...layout} : {}\n    return compact(correctBounds(layout, cols))\n}\n\n/**\n * Given breakpoints, return an array of breakpoints sorted by width. This is usually\n * e.g. ['xs', 'sm', ...]\n *\n * @param  {Object} breakpoints Key/value pair of breakpoint names to widths.\n * @return {Array}              Sorted breakpoints.\n */\nexport function sortBreakpoints(breakpoints: Breakpoints): Array<Breakpoint>{\n    const keys = Object.keys(breakpoints) as Array<Breakpoint>\n    return keys.sort((a, b) => (breakpoints[a] || 0) - (breakpoints[b] || 0))\n}\n"],"file":"responsiveUtils.js"}